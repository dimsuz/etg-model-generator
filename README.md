# Reactive Model Generator

Given

```kotlin
@GenerateReducingImplementation(baseClass = SerialReactiveModel::class)
interface SampleModel {
  fun fetchMovieList(userId: String)
  fun fetchMovieListState(): Observable<LceState<List<Movie>>>

  fun saveMovieRating(userId: String, movieId: String)
  fun saveMovieRatingState(): Observable<LceState<Unit>>

  fun movieGenreList(): Observable<List<Genre>>
}
```

this processor will generate this model implementation.
It will be based on an interface `SampleModelOperations` which is also generated for you to implement:

```kotlin
// Generated by processor
interface SampleModelOperations {
  fun createFetchMovieListOperation(userId: String, state: SampleModelImpl.State): Single<LceState<List<Movie>>>

  fun createSaveMovieRating(userId: String, movieId: String, state: SampleModelImpl.State): Completable

  fun movieGenreList(): Observable<List<Genre>>
}
```

Reactive properties are recognized based on the returned LCE state type. To tell the processor about this type you'll need to provide it with 3 annotated function-constructors, for example:

```kotlin
data class LceState<C>(
  val isLoading: Boolean,
  val content: C?,
  val error: Throwable?
)

@LceContentConstructor
fun <C> createLceContent(content: C): LceState<C> {
  return LceState(isLoading = false, content = content, error = null)
}

@LceLoadingConstructor
fun <C> createLceLoading(content: C? = null): LceState<C> {
  return LceState(isLoading = true, content = content, error = null)
}

@LceErrorConstructor
fun <C> createLceError(error: Throwable, content: C? = null): LceState<C> {
  return LceState(isLoading = false, content = content, error = error)
}
```

After processor knows about LCE state type, it will search for reactive getters â€” functions with return type `Observable<LceState<*>>`, and then attempt to find matching "request"-functions by removing `State` suffix from getter name. For example: getter `saveMovieRatingState` should have request named `saveMovieRating` to be found by processor.

All methods of the model interface which are not recognized as reactive getters/requests will be copied to generated `operations`-interface without any changes (see `movieGenreList()` in the above example)

To create an instance of the model which uses the generated implementation call:

```kotlin
val operationsImpl = object : SampleModelOperations {
   // Tyour implementation
}
val model = ModelGenerator.createModel(operationsImpl)
model.fetchMovieListState().subscribe({ println("Got list $it")})
model.fetchMovieList("my-user-id")
```
